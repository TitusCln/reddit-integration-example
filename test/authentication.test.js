const zapier = require('zapier-platform-core');
const nock = require('nock');
const config = require('config');

zapier.tools.env.inject();

const App = require('../index');
const appTester = zapier.createAppTester(App);
const tokenResponse = require('./fixtures/responses/tokenResponse.json');

// Only here so the tests out of the box.
// You should create a `.env` file and populate it with the necessarily configuration
// it should look like:
/*
    CLIENT_ID=1234
    CLIENT_SECRET=asdf
*/
// then you can delete the following 2 lines
process.env.CLIENT_ID = process.env.CLIENT_ID || '1234';
process.env.CLIENT_SECRET = process.env.CLIENT_SECRET || 'asdf';

describe('oauth2 app', () => {
  let bundle;
  beforeAll(() => {
    bundle = {
      // In production, these will be generated by Zapier and set automatically
      inputData: {
        state: '4444',
        redirect_uri: 'https://zapier.com/',
      },
      environment: {
        CLIENT_ID: process.env.CLIENT_ID,
        CLIENT_SECRET: process.env.CLIENT_SECRET,
      },
    };

    if (!(config.get('Auth.CLIENT_ID') && config.get('Auth.CLIENT_SECRET'))) {
      throw new Error(
        `Before running the tests, make sure CLIENT_ID and CLIENT_SECRET are available in the environment.`
      );
    }

    nock('https://www.reddit.com')
      .post('/api/v1/access_token')
      .reply(200, tokenResponse);
  });

  expect();
  it('is of type oauth2', () => expect(App.authentication.type).toBe('oauth2'));

  it('generates an authorize URL', async () => {
    const authorizeUrl = await appTester(
      App.authentication.oauth2Config.authorizeUrl,
      bundle
    );

    expect(authorizeUrl).toBe(
      `https://www.reddit.com/api/v1/authorize?client_id=${config.get(
        'Auth.CLIENT_ID'
      )}&state=4444&redirect_uri=https%3A%2F%2Fzapier.com%2F&response_type=code&scope=identity%20submit%20save%20read&duration=permanent`
    );
  });

  it('returns access/refresh tokens and a user_id', async () => {
    result = await appTester(
      App.authentication.oauth2Config.getAccessToken,
      bundle
    );

    expect(result.access_token).toBe(tokenResponse.access_token);
  });
});
